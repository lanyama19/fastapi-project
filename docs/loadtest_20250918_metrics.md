# 2025-09-18 压测结果记录

## 测试参数
- 场景：`loadtests/locust_v2.py`
- 并发：200 个用户，爬升速率 40 用户/秒
- 持续时长：10 分钟 (`--run-time 600s`)
- 数据来源：`loadtest_20250918_100740` 日志归档

## 关键指标
| 接口 | 请求数 | 失败数 | 平均耗时 (ms) | P50 (ms) | P90 (ms) | 备注 |
| --- | --- | --- | --- | --- | --- | --- |
| POST /v2/users | 200 | 195 | 133,439 | 138,000 | 140,000 | 多数请求 60s+ 超时后被 Locust 标记失败 |
| POST /v2/auth/login | 5 | 2 | 36,946 | 32,000 | 86,000 | 登录阶段同样遇到连接被动断开 |
| POST /v2/posts | 3 | 3 | 71,355 | 60,000 | 94,000 | 发帖请求几乎全部失败 |
| GET /v2/posts | — | — | 14,916 | 4,000 | 29,000 | 受上游失败影响，样本量不足 |
| POST /v2/vote | — | — | 25,302 | 4,200 | 158,000 | 同上 |
| **汇总** | 208 | 200 | 130,224 | 138,000 | 140,000 | 总体失败率 ≈ 96% |

## 失败类型
- `locust_20250918_100740_failures.csv` 显示主要错误为 `CatchResponseError('注册失败: 0 None')`，说明服务端在返回状态码前就断开连接。
- `fastapi_journal_20250918_100740.log` 多次出现 `WORKER TIMEOUT` 与 `Worker ... was sent SIGKILL! Perhaps out of memory?`，表明 Gunicorn worker 在 60 秒超时后被强杀。
- worker 被杀与 bcrypt 加密耗时相关：注册阶段为每个用户现算密码散列，4 个 worker 持续阻塞，导致所有请求排队并最终超时。

## 系统资源情况
- `system_20250918_100740.log` 显示压测期间 2 核 CPU 长时间处于高 `%wait` 状态，`locust` 与 `gunicorn` 占满可用 CPU。
- `kswapd0`、`snapd` 等进程也在抢占资源，进一步延长响应时间。
- 数据库连接未被持续跟踪（`db_20250918_100740.log` 为空），结合日志推断主要瓶颈在应用层 CPU 耗尽而非 PostgreSQL。

## 结论与建议
1. **避免压测阶段重复注册**：提前用脚本创建压测账号或复用现有账号，减少 bcrypt CPU 消耗。
2. **调低 bcrypt 轮次用于测试**：单机压测时把轮次降到 8，可显著降低登录/注册成本；线上仍保持高轮次。
3. **控制 worker 数量与超时**：在 2 核主机上建议使用 2 个 Gunicorn worker，同时把 `--timeout` 提升到 120s 以上，仅在压测阶段使用。
4. **监控数据库连接与系统负载**：下次运行脚本时设置 `DB_DSN`，并确保无额外后台任务（如 `apt-get`、`snapd`）占用大量 CPU。

import json
import os
import random
from collections import deque
from pathlib import Path
from threading import Lock
from typing import Any, Deque, Dict, Optional
from uuid import uuid4

from locust import FastHttpUser, constant_pacing, events, task
from locust.exception import StopUser


DEFAULT_USERS_FILE = os.getenv(
    "LOADTEST_USERS_FILE",
    str(Path(__file__).resolve().with_name("test_users.json")),
)


@events.init_command_line_parser.add_listener
def _(parser) -> None:
    parser.add_argument(
        "--users-file",
        default=DEFAULT_USERS_FILE,
        help="Path to JSON credentials generated by scripts/seed_test_users.py",
    )


@events.test_start.add_listener
def _load_credentials(environment, **_) -> None:
    queue, lock = _ensure_store(environment)
    with lock:
        queue.clear()
        users_file = Path(environment.parsed_options.users_file)
        data = json.loads(users_file.read_text())
        users = data.get("users", [])
        if not users:
            raise RuntimeError(f"No users found in {users_file}")
        for entry in users:
            queue.append(entry)


def _ensure_store(environment) -> tuple[Deque[Dict[str, Any]], Lock]:
    queue = getattr(environment, "credential_queue", None)
    lock = getattr(environment, "credential_lock", None)
    if queue is None:
        queue = deque()
        environment.credential_queue = queue
    if lock is None:
        lock = Lock()
        environment.credential_lock = lock
    return queue, lock


class V2ApiUser(FastHttpUser):
    """Exercise authentication, post, and vote flows for the v2 API."""

    wait_time = constant_pacing(0.1)

    def on_start(self) -> None:
        self.known_post_ids: set[int] = set()
        self.auth_headers: Dict[str, str] = {}
        credential = self._acquire_credential()
        if credential is None:
            raise StopUser()
        self.credential = credential
        try:
            self._login()
            self._create_post(seed=True)
        except StopUser:
            self._release_credential()
            raise

    def on_stop(self) -> None:
        self._release_credential()

    def _acquire_credential(self) -> Optional[Dict[str, Any]]:
        queue, lock = _ensure_store(self.environment)
        with lock:
            if not queue:
                return None
            return queue.popleft()

    def _release_credential(self) -> None:
        credential = getattr(self, "credential", None)
        if not credential:
            return
        queue, lock = _ensure_store(self.environment)
        with lock:
            queue.append(credential)

    def _login(self) -> None:
        payload = {
            "username": self.credential["email"],
            "password": self.credential.get("password", ""),
        }
        with self.client.post(
            "/v2/auth/login",
            data=payload,
            headers={"Content-Type": "application/x-www-form-urlencoded"},
            name="POST /v2/auth/login",
            catch_response=True,
        ) as response:
            if response.status_code != 200:
                response.failure(f"Login failed: {response.status_code} {response.text}")
                raise StopUser()
            token = response.json().get("access_token")
            if not token:
                response.failure("Login response did not include an access token")
                raise StopUser()
            self.auth_headers = {"Authorization": f"Bearer {token}"}
            response.success()

    def _create_post(self, seed: bool = False) -> None:
        payload = {
            "title": f"Locust post {uuid4().hex}",
            "content": "Load test body",
            "published": True,
        }
        with self.client.post(
            "/v2/posts/",
            headers=self.auth_headers,
            json=payload,
            name="POST /v2/posts",
            catch_response=True,
        ) as response:
            if response.status_code == 201:
                post_id = response.json()["id"]
                self.known_post_ids.add(post_id)
                response.success()
            else:
                response.failure(f"Post creation failed: {response.status_code} {response.text}")
                if seed:
                    raise StopUser()

    @task(3)
    def list_posts(self) -> None:
        with self.client.get(
            "/v2/posts/",
            headers=self.auth_headers,
            name="GET /v2/posts",
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                for item in response.json():
                    post = item.get("post")
                    if post and "id" in post:
                        self.known_post_ids.add(post["id"])
                response.success()
            else:
                response.failure(f"List posts failed: {response.status_code} {response.text}")

    @task(2)
    def create_post_task(self) -> None:
        self._create_post()

    @task(2)
    def vote_task(self) -> None:
        if not self.known_post_ids:
            return
        post_id = random.choice(tuple(self.known_post_ids))
        direction = random.choice([0, 1])
        with self.client.post(
            "/v2/vote/",
            headers=self.auth_headers,
            json={"post_id": post_id, "dir": direction},
            name="POST /v2/vote",
            catch_response=True,
        ) as response:
            if response.status_code == 201:
                response.success()
            elif direction == 0 and response.status_code == 404:
                response.success()
            elif direction == 1 and response.status_code == 409:
                response.success()
            else:
                response.failure(
                    f"Vote failed: dir={direction} status={response.status_code} body={response.text}"
                )
